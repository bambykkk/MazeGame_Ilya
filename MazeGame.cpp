// MazeGame.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <conio.h>
#include "time.h"
#include "windows.h"
#include "CrtLib.h"


using namespace std;
using namespace crt;
HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
const int LX = 75;
const int LY = 30;
const char mine2 = (char)15;//мина2
const char mine = (char)15;//мина
const char ta = (char)30;//время
const char diamond = (char)4;//алмаз
const char player = (char)1;
// 0 - пустое пространство
// 1 - стена 
// 2 - выход
// 3 - игрок
// 4 - монета
// 5 - алмаз
// 6 - время
// 7 - мина
// 8 - мина2
int maze[LY][LX] = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,3,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,4,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,4,0,0,0,0,0,0,1,0,1,1,1},
    {1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1},
    {1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1},
    {1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1},
    {1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1},
    {1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,1},
    {1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1},
    {1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,7,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
    {1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,4,1,0,1,0,0,0,0,0,1,0,4,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,4,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1},
    {1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1},
    {1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,6,1,0,0,0,0,0,0,0,1,5,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1},
    {1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1},
    {1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,1},
    {1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1},
    {1,0,0,0,1,0,0,0,0,0,1,0,1,5,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,8,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,1,1},
    {1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1},
    {1,0,0,0,0,0,1,0,4,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1},
    {1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1},
    {1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,4,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1},
    {1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1},
    {1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,4,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,4,1,1,1,1,1},
    {1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
    {1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,6,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
    {1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1},
    {1,0,1,0,1,0,1,0,1,0,0,0,0,4,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,4,1,0,0,2,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};


    // глобальные переменные
    int hx, hy; // позиция игрока в лабиринте
    int score = 0; // счет игры
    int gameState = 0; // 0 - игра продолжается, 1 - выигрыш, 2 - закончилось время
    int timeLimit = 240; // лимит игры в секундах
    int gameTime; // оставшееся время

   clock_t tstart; // значение счетчика таймера при старте игры

// Функция обновляет текущий счет на экране
void UpdateScore(int score)
{
    GotoXY(35, 30); // ставим курсор на последнюю строку консоли
    setlocale(LC_ALL, "ru-RU"); // включаем локаль, ориентированную на кириллицу
    SetConsoleTextAttribute(hConsole, 11);
    cout << "СЧЕТ: " << score;  // выводим счет на экран
    setlocale(LC_ALL, "C"); // возвращаем настройки локали по умолчанию
}

// Функция обновляет оставшееся время до окончания игры
// параметр t функции - это текущее значение системного таймера, на момент вызова функции
void UpdateClock(clock_t t, clock_t& start, int& gState, int& gTime,int& tLimit)
{
    gameTime = timeLimit - (t - tstart) / CLOCKS_PER_SEC; /* вычисляем оставшееся время в секундах
                    и помещаем результат в gameTime. (t-tstart) - кол-во миллисекунд, прошедшее
                    с момента старта игры. CLOCKS_PER_SEC - константа, определяющая количество
                    изменений системного таймера за 1 секунду. Для Windows это значение 
                    равно 1000. Вычитая из timeLimit время, прошедшее с начала игры, мы вычисляем
                    остаток времени в секундах */
    setlocale(LC_ALL, "ru-RU"); // переключаем локаль
    if (gameTime < 0) // проверяем, закончилось ли время
    {
        gameState = 2; // если да, то обновляем статус игры на 2 - игрок ПРОИГРАЛ
    }
    else
    {  // если время осталось
        GotoXY(49, 30); // ставим курсор на последнюю строку
        if (gameTime > 15) {
            SetConsoleTextAttribute(hConsole, 10);
        }
        else;
        if (gameTime <= 15)
        {
            SetConsoleTextAttribute(hConsole, 12);
        }
        cout << "Осталось: " << gameTime << " секунд "; // выводим остаток времени в консоль
    }
    setlocale(LC_ALL, "C"); // восстанавливаем настройки локали
}

// Функция печатает в консоли лабиринт
void PrintMaze(int maze[LY][LX], int sizeX, int sizeY)
{
    for (int i = 0; i < sizeY; i++)
    {
        for (int j = 0; j < sizeX; j++)
        {
            switch (maze[i][j])
            {
            case 0:
                cout << ' ';
                break;
            case 1:
                SetConsoleTextAttribute(hConsole,12);
                cout << (char)178;
                
                break;
            case 2:
                SetConsoleTextAttribute(hConsole, 8);
                cout << (char)176;
                break;
            case 3:
                SetConsoleTextAttribute(hConsole, 15);
                cout << player;
                
                break;
            case 4:
                SetConsoleTextAttribute(hConsole, 14);
                cout << '$';//манетка
                break;
            case 5:
                SetConsoleTextAttribute(hConsole, 13);
                cout << diamond;//алмаз
                break;
            case 6:
                SetConsoleTextAttribute(hConsole, 10);
                cout<<ta;//время
                break;
            case 7:
                SetConsoleTextAttribute(hConsole,4 );
                cout << mine;//мина
                break;
            case 8:
                SetConsoleTextAttribute(hConsole, 4);
                cout << mine2;//мина2
                break;
            default:
                cout << '?';
            }
        }
        cout << endl;
    }
}





// Функция определяет позицию игрока в массиве, обновляя значения глобальных переменных hx и hy
bool FindFirstPlayerPosition(int maze[LY][LX], int sizeX, int sizeY, int& hx, int& hy)

{
    setlocale(LC_ALL, "ru-RU");
    int KolichestvoIgrokov = 0;
    int KolichestvoVihodov = 0;

    for (int i = 0; i < sizeY; i++)  // цикл пробегает массив по строкам
    {
        for (int j = 0; j < sizeX; j++) // цикл пробегает массив по столбцам
        {
            if (maze[i][j] == 3)    // проверяем, если текущий элемент равен 3 - нашли
            {                       // требуемую 
                KolichestvoIgrokov++;
                hx = j;             // записываем столбец в hx
                hy = i;             // записываем строку в hy
                // завершаем работу функции
            }
            else if (maze[i][j] == 2)
            {
                KolichestvoVihodov++;
            }
        }
    }
    // если ничего не нашли - предполагаем, что игрок в позиции 0,0
    if (KolichestvoIgrokov == 1 && KolichestvoVihodov >= 1)
    {
        return true;
    }
    else if (KolichestvoIgrokov == 0 || KolichestvoVihodov > 1 || KolichestvoVihodov == 0)
    {
        system("cls");
        cout << "ошибка" << endl;
        return false;
    }

    return false;
}                           // это нелогично, но пока ничего предпринимать не будем, решение
                    // этой проблемы будет вашим персональным заданием по рефакторингу игры

//Функция скрывает игрока с экрана и убирает его из лабиринта
void HidePlayer()
{
    maze[hy][hx] = 0; // записываем в текущую позицию матрицы число 0
    GotoXY(hx, hy); // устанавливаем курсор в позицию игрока в консоль
    cout << ' ';    // и печатаем пробел
}

// функция показывает на экране игрока и записывает его в лабиринт
void ShowPlayer()
{
    maze[hy][hx] = 3 ; // записываем в текущую позицию матрицы число 0
    GotoXY(hx, hy); // устанавливаем курсор в позицию игрока в консоль
    SetConsoleTextAttribute(hConsole, 15);
    cout << player; // и печатаем образ игрока
}




void MovePlayer(int dx, int dy)
{
    int new_hx = hx + dx; // новая координата x
    int new_hy = hy + dy; // новая координата y

    // Проверяем, что новые координаты находятся в пределах лабиринта
    if (new_hx >= 0 && new_hx < LX && new_hy >= 0 && new_hy < LY)
    {
        int cell = maze[new_hy][new_hx]; // значение ячейки в новой позиции

        switch (cell)
        {
        case 0: // если пустая клетка
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            break;
        case 2: // если дверь выхода
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            UpdateScore(score += 500);
            gameState = 1;
            break;
        case 4: // если монета
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            UpdateScore(score += 100);
            break;
        case 5: // если алмаз
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            UpdateScore(score += 300);
            break;
        case 6: // если добавление времени
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
             UpdateClock(clock(), tstart, gameState, gameTime, timeLimit += 10);
            break;
        case 7: // если добавление мины
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            UpdateScore(score -= 200);
            break;
        case 8: // если добавление мины2
            HidePlayer();
            hx = new_hx;
            hy = new_hy;
            ShowPlayer();
            UpdateClock(clock(), tstart, gameState, gameTime,timeLimit -= 8);
            break;
        }
    }
}

// Функция обрабатывает события клавиатуры и управляет игрой
void Control(int& gameState)
{
    clock_t tstart;
    tstart = clock();  // запоминаем счетчик системного таймера в момент старта игры.
    UpdateScore(score); // обновляем счет игры, изначально он нулевой
    unsigned char x;  // это переменная хранит символ, соответствующий нажатой клавише
    while (gameState == 0)  // цикл игры - пока gameState == 0, игра идет
    {
        UpdateClock(clock(), tstart, gameState, gameTime, timeLimit);   // обновляем оставшееся время
        if (_kbhit())           // если была нажата клавиша - то обрабатываем ее, иначе следующая
        {                       // итерация игрового цикла
            x = _getch();       // считываем символ нажатой клавиш,
            if (x == 27) return;// если это символ Esc (27) то это выход из игры
            if (x == 0xe0)      // если это символ с кодом 0xE0 (шестнадцатеричное)
                switch (_getch()) // то считываем еще один символ (некоторые клавиши выдают двойные коды)
                {
                case 72:          // если 2-й символ код 72, то это клавиша курсор вверх
                    MovePlayer(0, -1);// идем вверх
                    break;
                case 80:          // если 2-й символ код 80, то это клавиша курсор вниз
                    MovePlayer(0, 1); // идем вниз
                    break;
                case 75:        // если 2-й символ код 75, то это клавиша курсор влево
                    MovePlayer(-1, 0);  // идем влево
                    break;
                case 77:        // если 2 - й символ код 77, то это клавиша курсор вправо
                    MovePlayer(1, 0); // двигаем игрока вправо   // идем вправо
                    break;
                }
        }
        Sleep(200);             // останавливаем игру на 200 мсек, если этого не делать, то
    } 
                          // обновление игры будет слишком быстрым, мы не сможем управлять
}                               // игроком, а также напрасно нагрузим процессор ненужной работой

void ShowGameOverMessage()
{
    setlocale(LC_ALL, "ru-RU");
    if (gameState == 1)
    {
        system("color 2");
        cout << '\t' << '\t' << "00    00 00  00000  00000000  00000  000000  00    00" << '\n' << '\t' << '\t' << "00    00 00 00   00    00    00   00 00   00  00  00" << '\n' << '\t' << '\t' << " 00  00  00 00         00    00   00 000000    0000" << '\n' << '\t' << '\t' << "  0000   00 00   00    00    00   00 00   00    00" << '\n' << '\t' << '\t' << "   00    00  00000     00     00000  00   00    00" << endl;
        cout << '\t' << '\t' << '\t' << '\t' <<" ------------" <<'\n'<<'\t' << '\t' << '\t' << '\t' << "| счет: " << score<<"  |"<<'\n'<<'\t' << '\t' << '\t' << '\t' << " ------------";
    }
    else;
    if (gameState == 2)
    {
        system("color 4");
        cout <<   "00000  00   00    000000 00000   0000  00  00 000000 00000   0000     000 00  00" << '\n' <<   "00  00 00   00    00  00 00  00 00  00 00  00 00     00  00 00  00   0 00 00  00" << '\n' <<   "00000  0000 00    00  00 00000  00  00 00 000 00     00000  000000  0  00 00 000" << '\n' <<   "00  00 00 0 00    00  00 00     00  00 000 00 00     00     00  00 00  00 000 00" << '\n' <<  "00000  0000 00    00  00 00      0000  00  00 00     00     00  00 00  00 00  00" ;
    }



}




// Функция main, которая выполняется при запуске прграммы
int main()
{
   
    
    system("mode con cols=80 lines=31");
    system("cls");
    PrintMaze(maze, LX, LY);
    FindFirstPlayerPosition(maze ,LX, LY,  hx,  hy);
    HideCursor();
    Control(gameState);
    ShowCursor();
    system("cls");
    system("color 7");
    ShowGameOverMessage();
}

